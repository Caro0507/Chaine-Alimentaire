Pour implémenter les simulations de boids, nous avons décidé de créer une classe abstraite Boid qui implémente toutes les fonctions communes à tous les types de boids. Il faut donc avoir une classe héritant de Boid par type de boid à implémenter. Dans ce cas seule la définition de la méthode resultante(), qui calcule la force résultante, est obligatoire. Mais il est aussi possible d'en redéfinir d'autre, comme nous l'avons fait pour certains type de boids. La classe Boid possède de nombreux attributs et méthodes statiques, car toute la gestion de la collection des boids est faite en statique, pusiqu'il n'y a qu'une simulation à la fois. Les classes filles peuvent néanmoins avoir une gestion interne des boids selon leur type par exemple. 
Nous avons fait deux simulations de boids, la première fait intervenir des SimpleBoid, qui est une classe de boids où la résultante multiplie chaque force par un poids avant divisé la somme par m. Les poids et la valeur de m sont passés en paramètre du constructeur. La seconde est une tentative de simulation chasseur-chassé avec l'exemple de faucons chassant des mulots. Il y a donc une classe Faucon et une classe Mulot, qui implémentent toutes les deux une résultante avec des poids statiques. Mais elles incluent aussi une redéfinition de l'affichage des boids pour, ce qui change la taille ou la couleur du triangle affiché.

Concernant les classes de simulation, BoidSimulator possède la même architecture que les précédents simulateurs au niveau des évênements, elle hérite de SingleEventSimulator. Il y a donc un évênement unique avec le même traitant pour chaque pas de simulation. L'initialisation est faite pour 120 boids de type SimpleBoid avec des positions et vitesse aléatoires. Il est possible de régler les valeurs de m et des poids directement dans le simulateur, la configuration actuelle permet d'obtenir un regroupement des boids en groupes.

Pour la seconde simulation nommée FauconsMulotSimulator, il y a un évênement particulier avec plusieurs sous-types, ce qui permet d'avoir un traitant pour les évênements relatifs aux faucons, et un traitant pour les évênements relatifs aux mulots. La classe de simulation implémente donc ces traitant, qui appellent les méthodes des classes Faucon et Mulot en charge d'avancer la simulation uniquement pour un des deux type de boids. Des méthodes en charge de la regénération des events ont aussi été ajoutés, et la méthode restart() a été redéfinie. 

Concernant les résulats, on observe bien des comportements de groupes après de nombreux essais passés à modifier les valeurs des poids. On remarques aussi que les boids deviennent très instables si leur champ de vision est faible, c'est peut-être une conséquence de nos paramètres qui ont été réglé pour un champ de vision à 360°. Nous avons eu moins de temps pour rafiner les paramètres de la simulation chasseurs-chassés, mais on observe déjà des résultats intéressants. Cependant en différentiant les voisins d'un faucon ou mulot selon son type il serait possible de l'améliorer encore. On peut aussi rêver à créer un réseau de neurone dont le but est d'apprendre à régler les paramètres selon une récompense issue des résultats de simulation, mais le réveil risque d'être difficile...

